name: Gemini AI Code Assistant

on:
  issues:
    types: [opened]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  ai-assistant:
    runs-on: ubuntu-latest
    # Only run if the issue has one of the AI labels
    if: |
      contains(github.event.issue.labels.*.name, 'ai-code-review') ||
      contains(github.event.issue.labels.*.name, 'ai-bug-fix') ||
      contains(github.event.issue.labels.*.name, 'ai-docs')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Gemini CLI
        run: |
          npm install -g @google/gemini-cli
          echo "Gemini CLI installed successfully"

      - name: Determine task type and prepare prompt
        id: prepare
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_LABELS: ${{ toJSON(github.event.issue.labels.*.name) }}
        run: |
          # Determine task type based on labels
          if echo '${{ toJSON(github.event.issue.labels.*.name) }}' | jq -r '.[]' | grep -q "ai-code-review"; then
            TASK_TYPE="code-review"
            PROMPT="You are a code review assistant for a NestJS project. Review the codebase and suggest specific improvements for:
          1. Code quality and maintainability
          2. Performance optimizations
          3. Best practices and design patterns
          4. Type safety improvements

          Focus on: ${ISSUE_BODY}

          IMPORTANT: Provide your response in the following JSON format:
          {
            \"changes\": [
              {
                \"file\": \"path/to/file.ts\",
                \"description\": \"Brief description of the change\",
                \"original\": \"code to replace\",
                \"modified\": \"new code\"
              }
            ],
            \"summary\": \"Overall summary of changes\"
          }"

          elif echo '${{ toJSON(github.event.issue.labels.*.name) }}' | jq -r '.[]' | grep -q "ai-bug-fix"; then
            TASK_TYPE="bug-fix"
            PROMPT="You are a debugging assistant for a NestJS project.
          Bug description: ${ISSUE_BODY}

          Analyze the codebase to:
          1. Identify the root cause of the bug
          2. Suggest a fix with exact file paths and code changes
          3. Consider edge cases and potential side effects

          IMPORTANT: Provide your response in the following JSON format:
          {
            \"changes\": [
              {
                \"file\": \"path/to/file.ts\",
                \"description\": \"Brief description of the fix\",
                \"original\": \"buggy code\",
                \"modified\": \"fixed code\"
              }
            ],
            \"summary\": \"Overall summary of the bug fix\"
          }"

          elif echo '${{ toJSON(github.event.issue.labels.*.name) }}' | jq -r '.[]' | grep -q "ai-docs"; then
            TASK_TYPE="docs"
            PROMPT="You are a documentation assistant for a NestJS project.
          Improve documentation for: ${ISSUE_BODY}

          Tasks:
          1. Add/improve JSDoc comments for functions and classes
          2. Update README.md if needed
          3. Add inline comments for complex logic
          4. Ensure API documentation is clear

          IMPORTANT: Provide your response in the following JSON format:
          {
            \"changes\": [
              {
                \"file\": \"path/to/file.ts\",
                \"description\": \"Brief description of documentation changes\",
                \"original\": \"code without docs\",
                \"modified\": \"code with docs\"
              }
            ],
            \"summary\": \"Overall summary of documentation improvements\"
          }"
          else
            TASK_TYPE="unknown"
            PROMPT="Unknown task type"
          fi

          echo "task_type=$TASK_TYPE" >> $GITHUB_OUTPUT
          echo "prompt<<EOF" >> $GITHUB_OUTPUT
          echo "$PROMPT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run Gemini AI Analysis
        id: ai-analysis
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # Run Gemini CLI with the prepared prompt (using gemini-2.0-flash for better rate limits)
          RESPONSE=$(gemini -p "${{ steps.prepare.outputs.prompt }}" --model gemini-2.0-flash --output-format json 2>&1 || echo "ERROR")

          if [ "$RESPONSE" = "ERROR" ]; then
            echo "Failed to run Gemini CLI"
            echo "response={\"error\": \"Failed to run Gemini CLI\"}" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Save response to file
          echo "$RESPONSE" > gemini_response.json
          echo "Gemini AI analysis completed"

          # Output for next step
          echo "response<<EOF" >> $GITHUB_OUTPUT
          echo "$RESPONSE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Apply changes
        id: apply-changes
        run: |
          # Parse Gemini response and apply changes
          if [ ! -f gemini_response.json ]; then
            echo "No response file found"
            exit 1
          fi

          # Check if there are changes to apply
          CHANGES_COUNT=$(jq -r '.changes | length' gemini_response.json 2>/dev/null || echo "0")

          if [ "$CHANGES_COUNT" = "0" ] || [ "$CHANGES_COUNT" = "null" ]; then
            echo "No changes to apply"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Applying $CHANGES_COUNT changes..."

          # Note: This is a simplified implementation
          # In production, you'd want more sophisticated parsing and validation
          # For now, we'll create a script that Gemini can output

          jq -r '.changes[] | @json' gemini_response.json | while read -r change; do
            FILE=$(echo "$change" | jq -r '.file')
            DESCRIPTION=$(echo "$change" | jq -r '.description')
            ORIGINAL=$(echo "$change" | jq -r '.original')
            MODIFIED=$(echo "$change" | jq -r '.modified')

            echo "Applying change to $FILE: $DESCRIPTION"

            # Apply the change if file exists
            if [ -f "$FILE" ]; then
              # Use sed or other tools to replace original with modified
              # This is a basic implementation - you may need more sophisticated logic
              if [ -n "$ORIGINAL" ] && [ "$ORIGINAL" != "null" ]; then
                # Create a temp file for the replacement
                TEMP_FILE="${FILE}.tmp"
                awk -v orig="$ORIGINAL" -v mod="$MODIFIED" '
                  BEGIN { found=0 }
                  {
                    if (!found && index($0, orig) > 0) {
                      gsub(orig, mod)
                      found=1
                    }
                    print
                  }
                ' "$FILE" > "$TEMP_FILE"
                mv "$TEMP_FILE" "$FILE"
              fi
            fi
          done

          echo "has_changes=true" >> $GITHUB_OUTPUT

      - name: Check for actual file changes
        id: check-changes
        run: |
          if git diff --quiet; then
            echo "No actual changes detected"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected"
            echo "has_changes=true" >> $GITHUB_OUTPUT
            git diff --stat
          fi

      - name: Create Pull Request
        if: steps.check-changes.outputs.has_changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create branch
          BRANCH_NAME="ai-assistant/issue-${ISSUE_NUMBER}-$(date +%s)"
          git checkout -b "$BRANCH_NAME"

          # Commit changes
          git add .
          git commit -m "AI: Improvements for issue #${ISSUE_NUMBER}

          This commit was automatically generated by Gemini AI assistant
          in response to issue #${ISSUE_NUMBER}.

          Co-Authored-By: Gemini AI <noreply@google.com>"

          # Push branch
          git push -u origin "$BRANCH_NAME"

          # Get summary from Gemini response
          SUMMARY=$(jq -r '.summary // "AI-generated improvements"' gemini_response.json)

          # Create PR using gh CLI
          gh pr create \
            --title "[AI] ${ISSUE_TITLE}" \
            --body "## Summary
          ${SUMMARY}

          ## Related Issue
          Closes #${ISSUE_NUMBER}

          ## Changes
          This PR contains AI-generated code improvements based on the issue description.
          Please review the changes carefully before merging.

          ---
          Generated by Gemini AI Code Assistant" \
            --base main \
            --head "$BRANCH_NAME"

          # Comment on the issue
          gh issue comment ${ISSUE_NUMBER} --body "ü§ñ AI Assistant has created a pull request with suggested changes. Please review carefully before merging."

      - name: Comment on failure
        if: failure()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          gh issue comment ${ISSUE_NUMBER} --body "‚ùå AI Assistant encountered an error while processing this issue. Please check the workflow logs for details."
